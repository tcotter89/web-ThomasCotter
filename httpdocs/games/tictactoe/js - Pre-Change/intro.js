var squareVerticesBuffer;
var squareVerticesColorBuffer;
var menuVerticesTextureCoordBuffer;
var horizAspect = 480.0 / 640.0;
var vertAspect = 640.0 / 480.0;
var squareRotation = 0.0;
var lastSquareUpdateTime;
var squareXOffset = 0.0;
var squareYOffset = 0.0;
var squareZOffset = 0.0;
var xIncValue = 0.2;
var yIncValue = -0.4;
var zIncValue = 0.3;
var menuTexture;
var menuImage;

function initBuffers() {
    squareVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);

    var vertices = [
      1.0, 1.0, 0.0,
      -1.0, 1.0, 0.0,
      1.0, -1.0, 0.0,
      -1.0, -1.0, 0.0
    ];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    //COLOR SECTION
    /*var colors = [
    1.0,  1.0,  1.0,  1.0,    // white
    1.0,  0.0,  0.0,  1.0,    // red
    0.0,  1.0,  0.0,  1.0,    // green
    0.0,  0.0,  1.0,  1.0     // blue
    ];
  
    squareVerticesColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);*/

    // Map the texture onto the menu

    cubeVerticesTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVerticesTextureCoordBuffer);

    var textureCoordinates = [
      0.0,  0.0,
      1.0,  0.0,
      0.0,  1.0,
      0.0,  1.0,
      1.0,  0.0,
      1.0,  1.0
    ];

    //Note: You will have to use Float32Array in place of WebGLFloatArray in WebKit based browsers. 
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                  gl.STATIC_DRAW);

}

//The initTextures() routine starts by creating the GL texture object cubeTexture by calling the GL createTexture() function. To load the texture from the image file, it then creates 
//  an Image object and loads into it the graphic file we wish to use as our texture. The handleTextureLoaded() callback routine is run when the image is done loading.
function initTextures() {
    menuImage = new Image();
    menuImage.onload = function () { render(menuImage); }
    menuImage.src = "menuTexture.jpg";
}

//The next two lines set up filtering for the texture; this controls how the image is filtered while scaling. In this case we're using linear filtering when scaling the image up, and 
//  a mipmap when scaling down. Then the mipmap is generated by calling generateMipMap(), and we finish up by telling WebGL we're done manipulating the texture by binding null to gl.TEXTURE_2D
function render(image, texture) {
    /*gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.bindTexture(gl.TEXTURE_2D, null);*/

    /*gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);*/
    var menuVerticesTextureCoordBuffer = gl.getAttribLocation(program, "aTextureCoord")
}

function drawScene() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    //The first step is to clear the context to our background color; then we establish the camera's perspective. We set a field of view of 45°, with a width to height ratio 
    //      of 640/480 (the dimensions of our canvas). We also specify that we only want objects between 0.1 and 100 units from the camera to be rendered.
    perspectiveMatrix = makePerspective(45, vertAspect, 0.1, 100.0);

    //Set the drawing position to the "identity" point, which is the center of the scene.
    loadIdentity();

    //Translate away from the camera by 6
    mvTranslate([-0.0, 0.0, -6.0]);

    //rotate the square around x and z axis
    mvPushMatrix();
    mvRotate(squareRotation, [1, 0, 1]);
    //mvTranslate([squareXOffset, squareYOffset, squareZOffset]);

    //set attributes of the object
    //  set position
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

    //  set color
    /*gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesColorBuffer);
    gl.vertexAttribPointer(vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);*/

    //  set texture
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, menuTexture);
    gl.uniform1i(gl.getUniformLocation(shaderProgram, "uSampler"), 0);

    //draw the objects
    setMatrixUniforms();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    //after drawing we need to restore the original matrix
    //  We save and restore the original matrix to avoid having this rotation applied to other objects we might draw.
    mvPopMatrix();


    var currentTime = (new Date).getTime();
    if (lastSquareUpdateTime) {
        var delta = currentTime - lastSquareUpdateTime;
        
        squareRotation += (30 * delta) / 1000.0;

        /*squareXOffset += xIncValue * ((30 * delta) / 1000.0);
        squareYOffset += yIncValue * ((30 * delta) / 1000.0);
        squareZOffset += zIncValue * ((30 * delta) / 1000.0);

        if (Math.abs(squareYOffset) > 2.5) {
            xIncValue = -xIncValue;
            yIncValue = -yIncValue;
            zIncValue = -zIncValue;
        }*/
    }

    lastSquareUpdateTime = currentTime;

}